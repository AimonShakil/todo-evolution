# Data Model: Task Entity

**Feature**: Add Task (Phase I Console)
**Branch**: `001-add-task`
**Date**: 2025-12-12
**Phase**: Phase 1 (Design & Contracts)

---

## Entity Overview

### Task

**Purpose**: Represents a single todo item with title, completion status, and audit timestamps.

**Lifecycle**:
1. **Created**: User runs `todo add --user <user_id> <title>`
2. **Persisted**: Stored in SQLite database (`todo.db`)
3. **Retrieved**: User queries tasks via `todo list --user <user_id>` (future feature)
4. **Updated**: User marks complete, edits title (future features)
5. **Deleted**: User removes task (future feature)

---

## Schema Definition

### SQLModel Class (`src/models/task.py`)

```python
from datetime import datetime
from sqlmodel import Field, SQLModel
from typing import Optional

class Task(SQLModel, table=True):
    """Task model with user isolation and constitutional fields.

    Constitutional Compliance (Principle VI):
    - id: Auto-incrementing primary key
    - user_id: User isolation (SECURITY CRITICAL - Principle II)
    - created_at: Audit timestamp (creation)
    - updated_at: Audit timestamp (last modification)

    Spec Compliance:
    - title: 1-200 characters (FR-002)
    - completed: Boolean default=False (FR-005)
    """
    __tablename__ = "tasks"

    # Constitutional fields (Principle VI - MANDATORY)
    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: str = Field(index=True, nullable=False, max_length=255)
    created_at: datetime = Field(default_factory=datetime.utcnow, nullable=False)
    updated_at: datetime = Field(default_factory=datetime.utcnow, nullable=False)

    # Domain fields (from spec.md)
    title: str = Field(min_length=1, max_length=200, nullable=False)
    completed: bool = Field(default=False, nullable=False)
```

---

## Field Specifications

| Field | Type | Constraints | Default | Purpose | Spec Ref |
|-------|------|-------------|---------|---------|----------|
| `id` | Integer | PRIMARY KEY, AUTO_INCREMENT | None (auto) | Unique identifier | FR-004 |
| `user_id` | String(255) | NOT NULL, INDEXED | N/A (required) | User isolation | FR-003, FR-007 |
| `created_at` | Timestamp | NOT NULL | UTC now | Creation audit | FR-005 |
| `updated_at` | Timestamp | NOT NULL | UTC now | Modification audit | FR-005 |
| `title` | String(200) | NOT NULL, 1-200 chars | N/A (required) | Task description | FR-001, FR-002 |
| `completed` | Boolean | NOT NULL | FALSE | Completion status | FR-005 |

---

## Field Details

### `id` (Primary Key)

- **Type**: Integer (SQLite: INTEGER PRIMARY KEY)
- **Constraints**: PRIMARY KEY, AUTO_INCREMENT
- **Range**: 1 to 2^63-1 (SQLite max integer)
- **Behavior**:
  - Auto-generated by database on INSERT
  - Unique across all users (global namespace)
  - Immutable after creation
- **Purpose**: Unique identifier for each task (spec FR-004)
- **Example Values**: 1, 2, 42, 1337

---

### `user_id` (User Isolation - SECURITY CRITICAL)

- **Type**: String (SQLite: VARCHAR(255))
- **Constraints**:
  - NOT NULL (spec FR-003: validation ensures non-empty)
  - INDEXED (Principle II: user isolation requires fast filtering)
  - Max length: 255 characters
- **Validation**:
  - Cannot be empty string (enforced by validator in `src/lib/validators.py`)
  - Accepts alphanumeric, underscores, hyphens, dots
  - No whitespace-only values
- **Purpose**: Identifies which user owns this task (spec FR-007: user data isolation)
- **Security**: **MANDATORY** - ALL queries MUST filter by this field (Principle II)
- **Example Values**: `"alice"`, `"bob123"`, `"user@example.com"`
- **Future Enhancement (Phase II)**: FK to `users.id` table (Better Auth integration)

---

### `created_at` (Audit Timestamp)

- **Type**: Timestamp (SQLite: TEXT in ISO 8601 format)
- **Constraints**: NOT NULL
- **Default**: `datetime.utcnow()` at creation time
- **Behavior**:
  - Set once on INSERT
  - Immutable (never updated)
  - Stored in UTC timezone
- **Purpose**: Audit trail - when task was created (spec FR-005, Principle VI)
- **Example Values**: `2025-12-12T10:30:00.123456`
- **Display Format**: `2025-12-12 10:30:00 UTC` (CLI output)

---

### `updated_at` (Modification Timestamp)

- **Type**: Timestamp (SQLite: TEXT in ISO 8601 format)
- **Constraints**: NOT NULL
- **Default**: `datetime.utcnow()` at creation time
- **Behavior**:
  - Set on INSERT to same value as `created_at`
  - Updated on every UPDATE operation (future features: complete, edit)
  - Stored in UTC timezone
- **Purpose**: Audit trail - when task was last modified (spec FR-005, Principle VI)
- **Example Values**: `2025-12-12T14:45:00.987654`
- **Future Enhancement**: Trigger or ORM event to auto-update on modification

---

### `title` (Task Description)

- **Type**: String (SQLite: VARCHAR(200))
- **Constraints**:
  - NOT NULL
  - Min length: 1 character (spec FR-002)
  - Max length: 200 characters (spec FR-002)
- **Validation** (enforced by Pydantic via SQLModel):
  - Empty string rejected (validation error: "Title cannot be empty")
  - Length >200 rejected (validation error: "Title must be 1-200 characters")
  - Emojis allowed (spec edge case: "Buy ü•õ milk")
  - Special characters allowed (spec edge case: "Read 'The Great Gatsby'")
  - Newlines/tabs sanitized or rejected (TBD in implementation)
- **Purpose**: User-provided task description (spec FR-001)
- **Example Values**:
  - `"Buy groceries"`
  - `"Call dentist at 2pm tomorrow"` (50 chars)
  - `"a"` (1 char - minimum)
  - `"x" * 200` (200 chars - maximum)

---

### `completed` (Completion Status)

- **Type**: Boolean (SQLite: INTEGER 0 or 1)
- **Constraints**: NOT NULL
- **Default**: `False` (spec FR-005)
- **Behavior**:
  - Created as `False` (incomplete)
  - Set to `True` via `todo complete` command (future feature)
  - Can be toggled back to `False` via `todo uncomplete` (future feature)
- **Purpose**: Tracks whether task is done (spec FR-005)
- **Example Values**: `False` (incomplete), `True` (complete)

---

## Indexes

### Primary Key Index

```sql
CREATE UNIQUE INDEX idx_tasks_id ON tasks(id);
```

- Automatically created by `PRIMARY KEY` constraint
- Ensures unique task IDs
- Enables fast lookups by ID

---

### User ID Index (MANDATORY)

```sql
CREATE INDEX idx_tasks_user_id ON tasks(user_id);
```

- **Purpose**: User isolation (Principle II - SECURITY CRITICAL)
- **Required For**:
  - Fast filtering: `SELECT * FROM tasks WHERE user_id = 'alice'`
  - Prevents full table scans
  - Enables sub-millisecond user-scoped queries
- **Performance**: O(log n) lookup vs. O(n) full scan
- **Example Query**:
  ```sql
  -- Without index: O(n) full scan
  -- With index: O(log n) B-tree lookup
  SELECT * FROM tasks WHERE user_id = 'alice';
  ```

---

### Composite Index (Future Optimization)

```sql
CREATE INDEX idx_tasks_user_created ON tasks(user_id, created_at DESC);
```

- **Purpose**: Optimize listing tasks sorted by creation date
- **Phase**: Deferred to Phase I expansion (when `todo list` implemented)
- **Benefits**:
  - Enables fast sorting: `ORDER BY created_at DESC`
  - Covers user filtering + sorting in single index
  - Avoids separate sort step

---

## Validation Rules

### Pydantic Validation (via SQLModel)

```python
# In src/models/task.py
from pydantic import validator

class Task(SQLModel, table=True):
    # ... fields ...

    @validator('title')
    def validate_title_length(cls, v: str) -> str:
        """Validate title is 1-200 characters (spec FR-002)."""
        if not v or len(v) < 1:
            raise ValueError("Title cannot be empty")
        if len(v) > 200:
            raise ValueError("Title must be 1-200 characters")
        return v

    @validator('user_id')
    def validate_user_id_not_empty(cls, v: str) -> str:
        """Validate user_id is not empty (spec FR-003)."""
        if not v or v.strip() == "":
            raise ValueError("User ID cannot be empty")
        return v
```

### Database Constraints

```sql
CREATE TABLE tasks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id VARCHAR(255) NOT NULL CHECK(LENGTH(user_id) > 0),
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    title VARCHAR(200) NOT NULL CHECK(LENGTH(title) BETWEEN 1 AND 200),
    completed INTEGER NOT NULL DEFAULT 0 CHECK(completed IN (0, 1))
);
```

---

## Relationships

### Phase I (No Relationships)

Task entity is standalone in Phase I. No foreign keys.

### Phase II (Future)

**User Relationship** (one-to-many):
```python
# Future: src/models/task.py
from sqlmodel import Relationship

class Task(SQLModel, table=True):
    # ... existing fields ...
    user: Optional["User"] = Relationship(back_populates="tasks")
```

**Tag Relationship** (many-to-many):
```python
# Future: src/models/task_tag.py (junction table)
class TaskTag(SQLModel, table=True):
    task_id: int = Field(foreign_key="tasks.id", primary_key=True)
    tag_id: int = Field(foreign_key="tags.id", primary_key=True)
```

---

## Migration Strategy

### Phase I ‚Üí Phase II (SQLite ‚Üí PostgreSQL)

**Schema Changes**:
```python
# Add priority field
priority: str = Field(default="medium", max_length=10)

# Add description field
description: Optional[str] = Field(default=None, max_length=1000)

# Add due_date field
due_date: Optional[datetime] = Field(default=None)

# Add tags relationship
tags: list["Tag"] = Relationship(back_populates="tasks", link_model=TaskTag)
```

**Alembic Migration**:
```python
# migrations/versions/002_add_priority_description_due_date.py
def upgrade():
    op.add_column('tasks', sa.Column('priority', sa.String(10), server_default='medium'))
    op.add_column('tasks', sa.Column('description', sa.String(1000), nullable=True))
    op.add_column('tasks', sa.Column('due_date', sa.DateTime(), nullable=True))
```

---

## Examples

### Create Task (Python)

```python
from src.models.task import Task
from datetime import datetime

# Valid task
task = Task(
    user_id="alice",
    title="Buy groceries",
    completed=False,
    created_at=datetime.utcnow(),
    updated_at=datetime.utcnow()
)
# id auto-generated by database

# Validation error: empty title
try:
    task = Task(user_id="alice", title="")
except ValueError as e:
    print(e)  # "Title cannot be empty"

# Validation error: title too long
try:
    task = Task(user_id="alice", title="a" * 201)
except ValueError as e:
    print(e)  # "Title must be 1-200 characters"
```

### Query Tasks (User Isolation)

```python
from sqlmodel import select, Session
from src.models.task import Task

# Get all tasks for alice (user isolation - Principle II)
statement = select(Task).where(Task.user_id == "alice")
tasks = session.exec(statement).all()

# SECURITY CRITICAL: NEVER query without user_id filter
# ‚ùå WRONG: select(Task)  # Cross-user data leakage!
# ‚úÖ CORRECT: select(Task).where(Task.user_id == user_id)
```

### Insert Task (SQL)

```sql
-- SQLite auto-generates id
INSERT INTO tasks (user_id, created_at, updated_at, title, completed)
VALUES ('alice', '2025-12-12T10:30:00', '2025-12-12T10:30:00', 'Buy groceries', 0);

-- Result: id=1 (auto-incremented)
```

---

## Test Cases

### Unit Tests (`tests/unit/test_task_model.py`)

```python
def test_task_creation_valid():
    """Test creating task with valid data."""
    task = Task(user_id="alice", title="Buy milk", completed=False)
    assert task.user_id == "alice"
    assert task.title == "Buy milk"
    assert task.completed is False

def test_task_title_min_length():
    """Test title minimum length (1 char)."""
    task = Task(user_id="alice", title="a", completed=False)
    assert task.title == "a"

def test_task_title_max_length():
    """Test title maximum length (200 chars)."""
    task = Task(user_id="alice", title="x" * 200, completed=False)
    assert len(task.title) == 200

def test_task_title_empty_rejected():
    """Test empty title raises ValidationError."""
    with pytest.raises(ValueError, match="Title cannot be empty"):
        Task(user_id="alice", title="", completed=False)

def test_task_title_too_long_rejected():
    """Test title >200 chars raises ValidationError."""
    with pytest.raises(ValueError, match="Title must be 1-200 characters"):
        Task(user_id="alice", title="x" * 201, completed=False)

def test_task_user_id_empty_rejected():
    """Test empty user_id raises ValidationError."""
    with pytest.raises(ValueError, match="User ID cannot be empty"):
        Task(user_id="", title="Buy milk", completed=False)

def test_task_emoji_in_title():
    """Test title with emoji (spec edge case)."""
    task = Task(user_id="alice", title="Buy ü•õ milk", completed=False)
    assert task.title == "Buy ü•õ milk"
```

---

## Constitutional Alignment

| Principle | Compliance | Evidence |
|-----------|------------|----------|
| **VI: Database Standards** | ‚úÖ PASS | Task model includes id, user_id, created_at, updated_at |
| **II: User Isolation** | ‚úÖ PASS | user_id field indexed, all queries filter by this field |
| **IX: Code Quality** | ‚úÖ PASS | Type hints, docstrings, Pydantic validation |
| **XII: Security** | ‚úÖ PASS | SQLModel ORM prevents SQL injection, user_id validation |

---

## Next Steps

1. ‚úÖ **Data Model Complete**: Task entity fully specified
2. ‚è≠Ô∏è **Create CLI Contract**: `contracts/add-task.md` - Command specification
3. ‚è≠Ô∏è **Create Quickstart Guide**: `quickstart.md` - Usage examples
4. ‚è≠Ô∏è **Implement Model**: `src/models/task.py` with tests
5. ‚è≠Ô∏è **Implement Service**: `src/services/task_service.py` with user isolation
